#!/usr/bin/env bash
# get-ns-secrets.sh - produce a list of Kubernetes namespaces for consumption by other functions
# v0.1 - initial
# v0.2 - get NSes
# v 03 - get secrets

set -o errexit
set -o pipefail
set -o nounset

# Record start time
START_TIME=$(date +%s)
START_TIME_HUMAN=$(date '+%Y-%m-%d %H:%M:%S')

# Function to print timing information
print_timing() {
  local END_TIME END_TIME_HUMAN ELAPSED ELAPSED_FMT
  END_TIME=$(date +%s)
  END_TIME_HUMAN=$(date '+%Y-%m-%d %H:%M:%S')
  ELAPSED=$((END_TIME - START_TIME))
  
  # Format elapsed time
  if [ $ELAPSED -ge 3600 ]; then
    ELAPSED_FMT="$((ELAPSED / 3600))h $((ELAPSED % 3600 / 60))m $((ELAPSED % 60))s"
  elif [ $ELAPSED -ge 60 ]; then
    ELAPSED_FMT="$((ELAPSED / 60))m $((ELAPSED % 60))s"
  else
    ELAPSED_FMT="${ELAPSED}s"
  fi
  
  echo "" >&2
  echo "=== Timing ===" >&2
  echo "Start:    $START_TIME_HUMAN" >&2
  echo "End:      $END_TIME_HUMAN" >&2
  echo "Elapsed:  $ELAPSED_FMT" >&2
}

PROG_NAME="${0##*/}"
FORMAT="lines"            # lines | csv | array
# Set flag for EXCLUSING system NSes
EXCLUDE_SYSTEM=true
ARRAY_NAME="NAMESPACES"
declare -a EXTRA_EXCLUDES=()

print_usage() {
  cat <<EOF
Usage: $PROG_NAME [options]

Options:
  -h, --help                 Show this help
  --format <lines|csv|array> Output format (default: lines)
  --array-name <NAME>        When --format array, name the generated array (default: NAMESPACES)
  --no-exclude-system        Do not exclude common system namespaces
  --exclude <ns1,ns2,...>    Comma or space separated additional namespaces to exclude
  --kubectl <path>           Path to kubectl binary (default: kubectl from PATH)
  --save-secrets <file.yaml> Save all secrets from each namespace to the specified YAML file
EOF
}

# Parse args (simple)
KUBECTL_BIN="kubectl"
SAVE_SECRETS_FILE=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) print_usage; exit 0 ;;
    --format) FORMAT="$2"; shift 2 ;;
    --format=*) FORMAT="${1#*=}"; shift 1 ;;
    --array-name) ARRAY_NAME="$2"; shift 2 ;;
    --array-name=*) ARRAY_NAME="${1#*=}"; shift 1 ;;
    --no-exclude-system) EXCLUDE_SYSTEM=false; shift ;;
    --exclude)
        # accept comma or space separated value(s)
        IFS=',' read -r -a tmp <<< "$2"
        for v in "${tmp[@]}"; do EXTRA_EXCLUDES+=("$v"); done
        shift 2
        ;;
    --exclude=*)
        val="${1#*=}"
        IFS=',' read -r -a tmp <<< "$val"
        for v in "${tmp[@]}"; do EXTRA_EXCLUDES+=("$v"); done
        shift
        ;;
    --kubectl) KUBECTL_BIN="$2"; shift 2 ;;
    --kubectl=*) KUBECTL_BIN="${1#*=}"; shift ;;
    --save-secrets)
        SAVE_SECRETS_FILE="$2"
        shift 2
        ;;
    --save-secrets=*)
        SAVE_SECRETS_FILE="${1#*=}"
        shift
        ;;
    *)
        echo "Unknown option: $1" >&2
        print_usage >&2
        exit 2
        ;;
  esac
done

# Validate format
case "$FORMAT" in
  lines|csv|array) ;;
  *)
    echo "Invalid --format: $FORMAT" >&2
    print_usage >&2
    exit 2
    ;;
esac

# Check kubectl availability
if ! command -v "$KUBECTL_BIN" >/dev/null 2>&1; then
  echo "Error: kubectl not found at '$KUBECTL_BIN' or in PATH." >&2
  exit 3
fi

# Common system namespaces to exclude by default (extend as needed)
# Includes Rancher cattle-* namespaces
SYSTEM_NAMESPACES=(
  kube-system kube-public kube-node-lease default kube-storage-local local-path-storage istio-system cert-manager
  cattle-system cattle-fleet-system cattle-fleet-local-system cattle-fleet-clusters-system
  cattle-global-nt cattle-global-data cattle-impersonation-system cattle-local-user-passwords cattle-monitoring-system
  cattle-resources-system cattle-capi-system cattle-turtles-system cattle-ui-plugin-system cattle-dashboards cattle-provisioning-capi-system fleet-default fleet-local
)

# Namespace prefixes to exclude (e.g. u-* user namespaces)
PREFIX_EXCLUDES=( "u-" "p-")

# Build final exclude set (exact-match)
declare -A EXCLUDE_MAP=()
if [ "$EXCLUDE_SYSTEM" = true ]; then
  for ns in "${SYSTEM_NAMESPACES[@]}"; do EXCLUDE_MAP["$ns"]=1; done
fi
for ns in "${EXTRA_EXCLUDES[@]}"; do
  # trim whitespace
  ns_trimmed="$(printf '%s' "$ns" | awk '{$1=$1;print}')"
  [ -n "$ns_trimmed" ] && EXCLUDE_MAP["$ns_trimmed"]=1
done

# Get namespaces from kubectl
namespaces_raw="$("$KUBECTL_BIN" get namespaces -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' 2>/dev/null || true)"

kubectl_exit=$?
if [ $kubectl_exit -ne 0 ] || [ -z "${namespaces_raw:-}" ]; then
  # Provide clearer errors if kubectl failed
  if [ $kubectl_exit -ne 0 ]; then
    echo "Error: 'kubectl get namespaces' failed (exit code $kubectl_exit)." >&2
    echo "Check your kubeconfig and current context: $KUBECTL_BIN config current-context" >&2
    exit 4
  fi
  # If empty, nothing to do
fi

# Helper: true if namespace matches any prefix in PREFIX_EXCLUDES
ns_matches_prefix() {
  local ns="$1"
  local p
  for p in "${PREFIX_EXCLUDES[@]}"; do
    [[ "$ns" == "$p"* ]] && return 0
  done
  return 1
}

# Prepare result array
declare -a result=()
while IFS= read -r ns; do
  [ -z "$ns" ] && continue
  if [ "${EXCLUDE_MAP[$ns]+_}" ]; then
    continue
  fi
  if ns_matches_prefix "$ns"; then
    continue
  fi
  result+=("$ns")
done <<< "$namespaces_raw"

# Output according to requested format
case "$FORMAT" in
  lines)
    if [ ${#result[@]} -eq 0 ]; then
      # print nothing but exit 0
      exit 0
    fi
    if [ -n "$SAVE_SECRETS_FILE" ]; then
      # Get namespaces again (reuse existing logic)
      namespaces=("${result[@]}")

      # Initialize or clear the output file
      : > "$SAVE_SECRETS_FILE"

      for ns in "${namespaces[@]}"; do
        echo "Fetching secrets for namespace: $ns" >&2
        # Get secrets in YAML format for the namespace
        secrets_yaml="$("$KUBECTL_BIN" get secrets -n "$ns" -o yaml 2>/dev/null || true)"
        if [ -n "$secrets_yaml" ]; then
          # Append namespace header and secrets to the file
          echo "---" >> "$SAVE_SECRETS_FILE"
          echo "# Namespace: $ns" >> "$SAVE_SECRETS_FILE"
          echo "$secrets_yaml" >> "$SAVE_SECRETS_FILE"
        fi
      done

      echo "Secrets saved to $SAVE_SECRETS_FILE" >&2
      print_timing
      exit 0
    fi
    for ns in "${result[@]}"; do
      printf '%s\n' "$ns"
    done
    ;;
  csv)
    if [ ${#result[@]} -eq 0 ]; then
      printf ''   # empty
      exit 0
    fi
    # join by comma
    first=true
    for ns in "${result[@]}"; do
      if [ "$first" = true ]; then
        printf '%s' "$ns"
        first=false
      else
        printf ',%s' "$ns"
      fi
    done
    printf '\n'
    ;;
  array)
    # Print a bash-friendly array assignment. Consumer can eval this safely in bash.
    # e.g. eval "$(./get-namespaces.sh --format array --array-name MYNS)"
    printf 'declare -a %s=( ' "$ARRAY_NAME"
    for ns in "${result[@]}"; do
      # escape double quotes and backslashes
      esc="${ns//\\/\\\\}"
      esc="${esc//\"/\\\"}"
      printf '"%s" ' "$esc"
    done
    printf ')\n'
    ;;
esac

print_timing
exit 0
