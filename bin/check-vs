#!/bin/bash
# v0.1 - initial
# v0.2 - Add in system NS
# v0.3 - Improved with verbose curl output for better debugging
# v0.4 - Fix the VS count
# v0.5 - Add start and end time 

# Script to detect VirtualServices in all namespaces and curl their hosts
# Uses 'curl -v' to show detailed connection information for debugging
# Requires: kubectl, curl, and appropriate cluster access

set -euo pipefail

# Record and print script start time
START_TIME=$(date '+%Y-%m-%d %H:%M:%S')
echo "Start time: $START_TIME"
START_TS=$(date +%s)

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

CURL_OPTS="--connect-timeout 5 --max-time 10"
VERBOSE=false
DRY_RUN=false
SKIP_SYSTEM_NS=true

# Accumulators for URLs per VirtualService (key: namespace/virtualservice, value: space-separated URLs)
# Using indexed arrays for macOS bash compatibility (no associative arrays)
VS_KEYS=()
VS_VALUES=()

# Add URL to a VirtualService bucket (deduplicated)
add_vs_url() {
	local namespace=$1
	local vs_name=$2
	local url=$3
	local key="${namespace}/${vs_name}"
	local current=""
	local idx
	local found=false

	# Find existing entry index for this key
	for i in "${!VS_KEYS[@]}"; do
		if [ "${VS_KEYS[$i]}" = "$key" ]; then
			idx=$i
			current="${VS_VALUES[$i]}"
			found=true
			break
		fi
	done

	# Deduplicate by checking for whole-word match
	if [[ " $current " != *" $url "* ]]; then
		local new_value
		if [ -z "$current" ]; then
			new_value="$url"
		else
			new_value="$current $url"
		fi
		if [ "$found" = true ]; then
			VS_VALUES[$idx]="$new_value"
		else
			VS_KEYS+=("$key")
			VS_VALUES+=("$new_value")
		fi
	fi
}

# Function to print usage
usage() {
    echo "Usage: $0 [-v] [-d] [-a] [-h]"
    echo "  -v             Verbose output (shows additional script details)"
    echo "  -d             Dry run - show what would be done without executing curls"
    echo "  -a             Include system namespaces (default: skip)"
    echo "  -h             Show this help message"
    echo ""
    echo "Curl Options Used:"
    echo "  --connect-timeout 5    Maximum time to wait for connection (5 seconds)"
    echo "  --max-time 10          Maximum time for entire operation (10 seconds)"
    echo "  -v                     Verbose output (shows connection details)"
    echo "  -s                     Silent mode (no progress bar)"
    echo "  -o /dev/null           Discard response body"
    echo "  -w \"%{http_code}\"      Write HTTP status code to stdout"
    echo ""
    echo "Note: This script uses 'curl -v' by default to show detailed connection information"
    exit 1
}

# Parse command line arguments
while getopts "vdah" opt; do
    case $opt in
        v) VERBOSE=true ;;
        d) DRY_RUN=true ;;
        a) SKIP_SYSTEM_NS=false ;;
        h) usage ;;
        *) usage ;;
    esac
done

# Check if curl is available
if ! command -v curl &> /dev/null; then
    echo -e "${RED}Error: curl is not installed or not in PATH${NC}"
    exit 1
fi

# Check if kubectl is available
if ! command -v kubectl &> /dev/null; then
    echo -e "${RED}Error: kubectl is not installed or not in PATH${NC}"
    exit 1
fi

# Function to print info messages
log_info() {
    echo -e "${GREEN}[INFO] $*${NC}"
}


# Function to print verbose messages
log_verbose() {
    if [ "$VERBOSE" = true ]; then
        echo -e "${BLUE}[VERBOSE] $*${NC}"
    fi
}

# Function to print warning messages
log_warning() {
    echo -e "${YELLOW}[WARNING] $*${NC}"
}

# Function to print error messages
log_error() {
    echo -e "${RED}[ERROR] $*${NC}"
}

# Function to check if namespace should be skipped
should_skip_namespace() {
    local namespace=$1
    
    # Change here for client NS
    if [ "$SKIP_SYSTEM_NS" = true ]; then
        case $namespace in
            kube-system|kube-public|kube-node-lease|default|istio-system|istio-operator)
                return 0  # Skip this namespace
                ;;
            *)
                # Also skip namespaces that start with kube- or istio-
                if [[ $namespace == kube-* ]] || [[ $namespace == istio-* ]]; then
                    return 0
                fi
                ;;
        esac
    fi
    return 1  # Don't skip this namespace
}

# Function to test connectivity to a host
test_host() {
    local host=$1
    local namespace=$2
    local vs_name=$3
    local protocol=${4:-http}
    local url="$protocol://$host"
    
    if [ "$DRY_RUN" = true ]; then
        echo -e "${YELLOW}DRY RUN: $url (VS: $vs_name, NS: $namespace)${NC}"
        return 0
    fi
    
    log_info "Testing: $url (VS: $vs_name, NS: $namespace)"
    echo -e "${CYAN}==============================================${NC}"
    
    # Run curl with verbose output and capture both stdout and stderr
    local curl_output
    local curl_exit_code
    
    # Capture verbose output to stderr and HTTP code to stdout
    curl_output=$(curl $CURL_OPTS -v -s -o /dev/null -w "%{http_code}" "$url" 2>&1)
    curl_exit_code=$?
    
    # Extract HTTP code from the end of the output
    local http_code
    http_code=$(echo "$curl_output" | tail -1)
    
    # Display the verbose curl output
    echo "$curl_output"
    
    echo -e "${CYAN}==============================================${NC}"
    
    # Check the results
    if [ $curl_exit_code -eq 0 ]; then
        if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 400 ]; then
            log_info "✓ $host: HTTP $http_code (VS: $vs_name, NS: $namespace)"
            return 0
        else
            log_warning "⚠ $host: HTTP $http_code (VS: $vs_name, NS: $namespace)"
            return 1
        fi
    else
        log_error "✗ $host: Connection failed (VS: $vs_name, NS: $namespace)"
        return 2
    fi
}

# Function to process a single namespace
process_namespace() {
    local namespace=$1
    local vs_count=0
    local host_count=0
    
    log_info "Checking namespace: ${PURPLE}$namespace${NC}"
    
    # Get all VirtualServices in the namespace
    if ! virtual_services=$(kubectl get virtualservice -n "$namespace" -o name 2>/dev/null); then
        log_verbose "No VirtualServices found in namespace $namespace or insufficient permissions"
        return
    fi
    
    if [ -z "$virtual_services" ]; then
        log_verbose "No VirtualServices found in namespace $namespace"
        return
    fi
    
    vs_count=$(echo "$virtual_services" | wc -l)
    log_info "Found $vs_count VirtualService(s) in $namespace"
    
    # Process each VirtualService
    while IFS= read -r vs; do
        if [ -z "$vs" ]; then
            continue
        fi
        
        vs_name=${vs#virtualservice.networking.istio.io/}
        log_info "Processing VirtualService: ${CYAN}$vs_name${NC}"
        
        # Get the VirtualService YAML and extract hosts
        hosts=$(kubectl get virtualservice "$vs_name" -n "$namespace" -o yaml | \
                grep -E "^\s+hosts:" -A 10 | \
                grep -E "^\s+-\s+" | \
                sed 's/^[[:space:]]*-\s*//' | \
                sed 's/"//g' | \
                tr -d "'" | \
                grep -v "^--" | \
                sort -u)
        
        if [ -z "$hosts" ]; then
            log_warning "No hosts found in VirtualService $vs_name"
            continue
        fi
        
        host_count_this_vs=$(echo "$hosts" | wc -l)
        host_count=$((host_count + host_count_this_vs))
        
        log_info "Hosts found in $vs_name:"
        echo "$hosts"
        
        # Test each host
        while IFS= read -r host; do
            if [ -n "$host" ] && [ "$host" != "null" ]; then
                # Track both HTTP and HTTPS URLs for summary output
                add_vs_url "$namespace" "$vs_name" "http://$host"
                add_vs_url "$namespace" "$vs_name" "https://$host"
                # Try HTTP first, then HTTPS if HTTP fails
                if ! test_host "$host" "$namespace" "$vs_name" "http"; then
                    log_verbose "HTTP failed, trying HTTPS..."
                    test_host "$host" "$namespace" "$vs_name" "https"
                fi
                echo
            fi
        done <<< "$hosts"
        
    done <<< "$virtual_services"
    
    # Update global totals
    total_vs_count=$((total_vs_count + vs_count))
    total_host_count=$((total_host_count + host_count))
    
    if [ $vs_count -gt 0 ]; then
        log_info "Processed $vs_count VirtualService(s) with $host_count host(s) in namespace $namespace"
    fi
}

# Main function
main() {
    log_info "Checking for VirtualServices across ALL namespaces"
    if [ "$SKIP_SYSTEM_NS" = true ]; then
        log_info "System namespaces will be skipped (use -a to include all)"
    else
        log_info "Including ALL namespaces (including system namespaces)"
    fi
    
    # Get all namespaces
    log_verbose "Fetching all namespaces..."
    namespaces=$(kubectl get namespaces -o jsonpath='{.items[*].metadata.name}')
    
    if [ -z "$namespaces" ]; then
        log_error "No namespaces found or insufficient permissions"
        exit 1
    fi
    
    total_namespaces=0
    processed_namespaces=0
    total_vs_count=0
    total_host_count=0
    
    # Process each namespace
    for namespace in $namespaces; do
        total_namespaces=$((total_namespaces + 1))
        
        if should_skip_namespace "$namespace"; then
            log_verbose "Skipping system namespace: $namespace"
            continue
        fi
        
        processed_namespaces=$((processed_namespaces + 1))
        process_namespace "$namespace"
        echo "=============================================="
    done
    
    # Summary
    log_info "=============================================="
    log_info "SUMMARY:"
    log_info "Total namespaces scanned: $total_namespaces"
    log_info "Namespaces processed: $processed_namespaces"
    log_info "Total VirtualServices found: $total_vs_count"
    log_info "Total hosts tested: $total_host_count"

    # URL printout removed per request
    
    if [ "$DRY_RUN" = true ]; then
        log_warning "DRY RUN MODE: No actual curl commands were executed"
    fi
    
    # Cleanup
    rm -f /tmp/curl_output
}

# Run main function
main "$@"

# Record and print script end time and elapsed duration
END_TIME=$(date '+%Y-%m-%d %H:%M:%S')
END_TS=$(date +%s)
ELAPSED_SECONDS=$((END_TS - START_TS))
ELAPSED_H=$((ELAPSED_SECONDS / 3600))
ELAPSED_M=$(((ELAPSED_SECONDS % 3600) / 60))
ELAPSED_S=$((ELAPSED_SECONDS % 60))

echo "Start time: $START_TIME"
echo "End time:   $END_TIME"
printf "Elapsed:    %ds (%02dh:%02dm:%02ds)\n" "$ELAPSED_SECONDS" "$ELAPSED_H" "$ELAPSED_M" "$ELAPSED_S"
