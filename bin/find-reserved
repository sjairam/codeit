#!/bin/bash
# v0.1 - initial - Find all reserved memory instances in Kubernetes cluster
# Finds pods with memory requests (reserved memory) across namespaces

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

KUBECTL=$(command -v kubectl)

# Function to display help options
Help() {
    echo -e "${BLUE}Find all reserved memory instances (memory requests) in a Kubernetes cluster${NC}"
    echo
    echo -e "${CYAN}Syntax: $0 [-h] [-n namespace] [-a] [-s]${NC}"
    echo -e "${YELLOW}options:${NC}"
    echo -e "-h                     Print this message."
    echo -e "-n namespace          Search in specific namespace only."
    echo -e "-a                     Show all namespaces (default)."
    echo -e "-s                     Sort by memory size (descending)."
    echo
    echo -e "${CYAN}Examples:${NC}"
    echo -e "  $0                    # Show all reserved memory in all namespaces"
    echo -e "  $0 -n default         # Show reserved memory in default namespace"
    echo -e "  $0 -s                 # Show all reserved memory sorted by size"
    echo
}

# Function to check the availability of required binaries
check_binaries() {
    if [ -z "${KUBECTL}" ]; then
        echo -e "${RED}ERROR: The kubectl binary does not exist.${NC}"
        echo -e "${YELLOW}FIX: Please ensure kubectl is installed and in your PATH.${NC}"
        exit 1
    fi
}

# Function to check kubectl connectivity
check_kubectl_access() {
    if ! ${KUBECTL} cluster-info &>/dev/null; then
        echo -e "${RED}ERROR: Cannot connect to Kubernetes cluster.${NC}"
        echo -e "${YELLOW}FIX: Please ensure kubectl is configured correctly and you have cluster access.${NC}"
        exit 1
    fi
}

# Function to convert memory values to bytes for sorting
convert_to_bytes() {
    local value=$1
    local unit=$(echo "$value" | sed 's/[0-9.]//g' | tr '[:lower:]' '[:upper:]')
    local num=$(echo "$value" | sed 's/[^0-9.]//g')
    
    case "$unit" in
        "KI"|"K")
            echo "$num * 1024" | bc
            ;;
        "MI"|"M")
            echo "$num * 1024 * 1024" | bc
            ;;
        "GI"|"G")
            echo "$num * 1024 * 1024 * 1024" | bc
            ;;
        "TI"|"T")
            echo "$num * 1024 * 1024 * 1024 * 1024" | bc
            ;;
        *)
            # Assume bytes if no unit
            echo "$num"
            ;;
    esac
}

# Function to find reserved memory
find_reserved_memory() {
    local namespace_arg=""
    local sort_flag=false
    
    # Parse command line arguments
    while getopts ':n:ash' opt; do
        case "$opt" in
            n)
                namespace_arg="-n ${OPTARG}"
                ;;
            a)
                namespace_arg="--all-namespaces"
                ;;
            s)
                sort_flag=true
                ;;
            h)
                Help
                exit 0
                ;;
            \?)
                echo -e "${RED}Invalid option: -$OPTARG${NC}" >&2
                Help
                exit 1
                ;;
            :)
                echo -e "${RED}Option -$OPTARG requires an argument.${NC}" >&2
                Help
                exit 1
                ;;
        esac
    done
    
    # Default to all namespaces if no namespace specified
    if [ -z "$namespace_arg" ]; then
        namespace_arg="--all-namespaces"
    fi
    
    # Check if bc is available for sorting
    if [ "$sort_flag" = true ] && ! command -v bc &>/dev/null; then
        echo -e "${YELLOW}WARNING: 'bc' not found. Sorting disabled. Install bc for size-based sorting.${NC}"
        sort_flag=false
    fi
    
    echo -e "${BLUE}Searching for pods with reserved memory (memory requests)...${NC}"
    echo
    
    # Get all pods with memory requests
    # Using JSON output to parse more reliably
    local pods_json
    pods_json=$(${KUBECTL} get pods ${namespace_arg} -o json 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        echo -e "${RED}ERROR: Failed to query Kubernetes cluster.${NC}"
        exit 1
    fi
    
    # Check if jq is available for JSON parsing
    if ! command -v jq &>/dev/null; then
        echo -e "${YELLOW}WARNING: 'jq' not found. Using basic parsing.${NC}"
        echo -e "${YELLOW}For better output, install jq.${NC}"
        echo
        
        # Fallback to basic kubectl output
        echo -e "${CYAN}NAMESPACE${NC}\t${CYAN}POD${NC}\t\t\t${CYAN}CONTAINER${NC}\t\t${CYAN}MEMORY REQUEST${NC}"
        echo "--------------------------------------------------------------------------------"
        ${KUBECTL} get pods ${namespace_arg} -o custom-columns=NAMESPACE:.metadata.namespace,NAME:.metadata.name,CONTAINER:.spec.containers[*].name,MEMORY-REQUEST:.spec.containers[*].resources.requests.memory 2>/dev/null | \
            grep -v "MEMORY-REQUEST.*<none>" | \
            awk 'NR>1 {print $0}'
        return
    fi
    
    # Use jq for better parsing
    # Print header
    printf "${CYAN}%-20s %-40s %-30s %-15s${NC}\n" "NAMESPACE" "POD" "CONTAINER" "MEMORY REQUEST"
    echo "--------------------------------------------------------------------------------"
    
    # Extract and display pod information
    if [ "$sort_flag" = true ]; then
        # Sort by memory size (requires conversion)
        # Create temporary file for sorting
        local temp_file=$(mktemp)
        
        echo "$pods_json" | jq -r '
            .items[] | 
            .metadata.namespace as $ns |
            .metadata.name as $pod |
            .spec.containers[]? | 
            select(.resources.requests.memory != null) |
            "\($ns)|\($pod)|\(.name)|\(.resources.requests.memory)"
        ' | while IFS='|' read -r namespace pod_name container_name memory_request; do
            if [ -n "$memory_request" ]; then
                memory_bytes=$(convert_to_bytes "$memory_request")
                printf "%s|%s|%s|%s|%s\n" "$memory_bytes" "$namespace" "$pod_name" "$container_name" "$memory_request" >> "$temp_file"
            fi
        done
        
        # Sort and display
        if [ -f "$temp_file" ] && [ -s "$temp_file" ]; then
            sort -t'|' -rn -k1 "$temp_file" | while IFS='|' read -r _ namespace pod_name container_name memory_request; do
                printf "%-20s %-40s %-30s %-15s\n" "$namespace" "$pod_name" "$container_name" "$memory_request"
            done
            rm -f "$temp_file"
        fi
    else
        # Display without sorting
        echo "$pods_json" | jq -r '
            .items[] | 
            .metadata.namespace as $ns |
            .metadata.name as $pod |
            .spec.containers[]? | 
            select(.resources.requests.memory != null) |
            "\($ns)|\($pod)|\(.name)|\(.resources.requests.memory)"
        ' | while IFS='|' read -r namespace pod_name container_name memory_request; do
            if [ -n "$memory_request" ]; then
                printf "%-20s %-40s %-30s %-15s\n" "$namespace" "$pod_name" "$container_name" "$memory_request"
            fi
        done
    fi
    
    # Count total containers with reserved memory
    local count=$(echo "$pods_json" | jq '[.items[] | .spec.containers[]? | select(.resources.requests.memory != null)] | length')
    
    echo
    echo -e "${GREEN}Found ${count} container(s) with reserved memory${NC}"
}

# Main execution
check_binaries
check_kubectl_access

# If no arguments provided, show all namespaces
if [ $# -eq 0 ]; then
    find_reserved_memory -a
else
    find_reserved_memory "$@"
fi
