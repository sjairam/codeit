#!/usr/bin/env bash
# get-ns-clustersecretstore - produce a list of Kubernetes namespaces and optionally export ClusterSecretStore resources
# v0.1 - initial (based on get-ns-secrets)
# ClusterSecretStore is cluster-scoped (External Secrets Operator); export uses single kubectl get

set -o errexit
set -o pipefail
set -o nounset

# Record start time
START_TIME=$(date +%s)
START_TIME_HUMAN=$(date '+%Y-%m-%d %H:%M:%S')

# Function to print timing information
print_timing() {
  local END_TIME END_TIME_HUMAN ELAPSED ELAPSED_FMT
  END_TIME=$(date +%s)
  END_TIME_HUMAN=$(date '+%Y-%m-%d %H:%M:%S')
  ELAPSED=$((END_TIME - START_TIME))

  # Format elapsed time
  if [ $ELAPSED -ge 3600 ]; then
    ELAPSED_FMT="$((ELAPSED / 3600))h $((ELAPSED % 3600 / 60))m $((ELAPSED % 60))s"
  elif [ $ELAPSED -ge 60 ]; then
    ELAPSED_FMT="$((ELAPSED / 60))m $((ELAPSED % 60))s"
  else
    ELAPSED_FMT="${ELAPSED}s"
  fi

  echo "" >&2
  echo "=== Timing ===" >&2
  echo "Start:    $START_TIME_HUMAN" >&2
  echo "End:      $END_TIME_HUMAN" >&2
  echo "Elapsed:  $ELAPSED_FMT" >&2
}

PROG_NAME="${0##*/}"
FORMAT="lines"            # lines | csv | array
# Set flag for EXCLUSING system NSes
EXCLUDE_SYSTEM=true
ARRAY_NAME="NAMESPACES"
declare -a EXTRA_EXCLUDES=()

print_usage() {
  cat <<EOF
Usage: $PROG_NAME [options]

Options:
  -h, --help                         Show this help
  --format <lines|csv|array>         Output format (default: lines)
  --array-name <NAME>                When --format array, name the generated array (default: NAMESPACES)
  --no-exclude-system                Do not exclude common system namespaces
  --exclude <ns1,ns2,...>            Comma or space separated additional namespaces to exclude
  --kubectl <path>                   Path to kubectl binary (default: kubectl from PATH)
  --save-clustersecretstore [dir]    Export ClusterSecretStore resources to YAML file: <kubecontext>_clustersecretstore_<timestamp>.yaml (default dir: .)
  --all-contexts                     Cycle through all contexts from kubeconfig (use with --save-clustersecretstore)
  --contexts <ctx1,ctx2,...>         Cycle through specified contexts only (use with --save-clustersecretstore)
EOF
}

# Parse args (simple)
KUBECTL_BIN="kubectl"
SAVE_CLUSTERSECRETSTORE_DIR=""   # empty = don't save; "." or path = save to kubecontext_clustersecretstore_timestamp.yaml
ALL_CONTEXTS=false
declare -a CONTEXTS_LIST=()      # empty = use current context; non-empty = use these contexts

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) print_usage; exit 0 ;;
    --format) FORMAT="$2"; shift 2 ;;
    --format=*) FORMAT="${1#*=}"; shift 1 ;;
    --array-name) ARRAY_NAME="$2"; shift 2 ;;
    --array-name=*) ARRAY_NAME="${1#*=}"; shift 1 ;;
    --no-exclude-system) EXCLUDE_SYSTEM=false; shift ;;
    --exclude)
        # accept comma or space separated value(s)
        IFS=',' read -r -a tmp <<< "$2"
        for v in "${tmp[@]}"; do EXTRA_EXCLUDES+=("$v"); done
        shift 2
        ;;
    --exclude=*)
        val="${1#*=}"
        IFS=',' read -r -a tmp <<< "$val"
        for v in "${tmp[@]}"; do EXTRA_EXCLUDES+=("$v"); done
        shift
        ;;
    --kubectl) KUBECTL_BIN="$2"; shift 2 ;;
    --kubectl=*) KUBECTL_BIN="${1#*=}"; shift ;;
    --save-clustersecretstore)
        if [[ -n "${2:-}" && "$2" != -* ]]; then
          SAVE_CLUSTERSECRETSTORE_DIR="$2"
          shift 2
        else
          SAVE_CLUSTERSECRETSTORE_DIR="."
          shift
        fi
        ;;
    --save-clustersecretstore=*)
        SAVE_CLUSTERSECRETSTORE_DIR="${1#*=}"
        shift
        ;;
    --all-contexts) ALL_CONTEXTS=true; shift ;;
    --contexts)
        IFS=',' read -r -a tmp <<< "$2"
        for v in "${tmp[@]}"; do
          v_trimmed="$(printf '%s' "$v" | awk '{$1=$1;print}')"
          [ -n "$v_trimmed" ] && CONTEXTS_LIST+=("$v_trimmed")
        done
        shift 2
        ;;
    --contexts=*)
        val="${1#*=}"
        IFS=',' read -r -a tmp <<< "$val"
        for v in "${tmp[@]}"; do
          v_trimmed="$(printf '%s' "$v" | awk '{$1=$1;print}')"
          [ -n "$v_trimmed" ] && CONTEXTS_LIST+=("$v_trimmed")
        done
        shift
        ;;
    *)
        echo "Unknown option: $1" >&2
        print_usage >&2
        exit 2
        ;;
  esac
done

# Validate format
case "$FORMAT" in
  lines|csv|array) ;;
  *)
    echo "Invalid --format: $FORMAT" >&2
    print_usage >&2
    exit 2
    ;;
esac

# Check kubectl availability
if ! command -v "$KUBECTL_BIN" >/dev/null 2>&1; then
  echo "Error: kubectl not found at '$KUBECTL_BIN' or in PATH." >&2
  exit 3
fi

# Common system namespaces to exclude by default (extend as needed)
# Includes Rancher cattle-* namespaces
SYSTEM_NAMESPACES=(
  kube-system kube-public kube-node-lease default kube-storage-local local-path-storage istio-system cert-manager
  cattle-system cattle-fleet-system cattle-fleet-local-system cattle-fleet-clusters-system
  cattle-global-nt cattle-global-data cattle-impersonation-system cattle-local-user-passwords cattle-monitoring-system
  cattle-resources-system cattle-capi-system cattle-turtles-system cattle-ui-plugin-system cattle-dashboards cattle-provisioning-capi-system fleet-default fleet-local
)

# Namespace prefixes to exclude (e.g. u-* user namespaces)
PREFIX_EXCLUDES=( "u-" "p-")

# Build final exclude set (exact-match)
declare -A EXCLUDE_MAP=()
if [ "$EXCLUDE_SYSTEM" = true ]; then
  for ns in "${SYSTEM_NAMESPACES[@]}"; do EXCLUDE_MAP["$ns"]=1; done
fi
for ns in "${EXTRA_EXCLUDES[@]}"; do
  # trim whitespace
  ns_trimmed="$(printf '%s' "$ns" | awk '{$1=$1;print}')"
  [ -n "$ns_trimmed" ] && EXCLUDE_MAP["$ns_trimmed"]=1
done

# Get namespaces from kubectl
namespaces_raw="$("$KUBECTL_BIN" get namespaces -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' 2>/dev/null || true)"

kubectl_exit=$?
if [ $kubectl_exit -ne 0 ] || [ -z "${namespaces_raw:-}" ]; then
  if [ $kubectl_exit -ne 0 ]; then
    echo "Error: 'kubectl get namespaces' failed (exit code $kubectl_exit)." >&2
    echo "Check your kubeconfig and current context: $KUBECTL_BIN config current-context" >&2
    exit 4
  fi
fi

# Helper: true if namespace matches any prefix in PREFIX_EXCLUDES
ns_matches_prefix() {
  local ns="$1"
  local p
  for p in "${PREFIX_EXCLUDES[@]}"; do
    [[ "$ns" == "$p"* ]] && return 0
  done
  return 1
}

# Prepare result array
declare -a result=()
while IFS= read -r ns; do
  [ -z "$ns" ] && continue
  if [ "${EXCLUDE_MAP[$ns]+_}" ]; then
    continue
  fi
  if ns_matches_prefix "$ns"; then
    continue
  fi
  result+=("$ns")
done <<< "$namespaces_raw"

# If --save-clustersecretstore: export ClusterSecretStore resources and exit
# ClusterSecretStore is cluster-scoped; no namespace iteration needed
# Optionally cycle through known kube contexts (--all-contexts or --contexts)
if [ -n "$SAVE_CLUSTERSECRETSTORE_DIR" ]; then
  ORIGINAL_CTX="$("$KUBECTL_BIN" config current-context 2>/dev/null || echo "")"

  # Build list of contexts to cycle through
  declare -a CTX_LIST=()
  if [ ${#CONTEXTS_LIST[@]} -gt 0 ]; then
    CTX_LIST=("${CONTEXTS_LIST[@]}")
  elif [ "$ALL_CONTEXTS" = true ]; then
    while IFS= read -r ctx; do
      [ -n "$ctx" ] && CTX_LIST+=("$ctx")
    done < <("$KUBECTL_BIN" config get-contexts -o name 2>/dev/null || true)
  else
    CTX_LIST+=("${ORIGINAL_CTX:-unknown}")
  fi

  if [ ${#CTX_LIST[@]} -eq 0 ]; then
    echo "Error: No contexts to process. Check --contexts or --all-contexts." >&2
    exit 5
  fi

  mkdir -p "$SAVE_CLUSTERSECRETSTORE_DIR"
  TIMESTAMP_FS=$(date '+%Y%m%d_%H%M%S')

  for KUBECTX in "${CTX_LIST[@]}"; do
    KUBECTX="$(printf '%s' "$KUBECTX" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    [ -z "$KUBECTX" ] && continue

    # Switch context (skip if same as current)
    CURRENT_CTX="$("$KUBECTL_BIN" config current-context 2>/dev/null || true)"
    if [ "$KUBECTX" != "$CURRENT_CTX" ]; then
      if ! "$KUBECTL_BIN" config use-context "$KUBECTX" >/dev/null 2>&1; then
        echo "Warning: Cannot switch to context '$KUBECTX', skipping." >&2
        continue
      fi
    fi

    TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    KUBECTX_SAFE="$(printf '%s' "$KUBECTX" | sed 's/[/: ]/-/g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//')"
    [ -z "$KUBECTX_SAFE" ] && KUBECTX_SAFE="unknown"

    SAVE_FILE="${SAVE_CLUSTERSECRETSTORE_DIR}/${KUBECTX_SAFE}_clustersecretstore_${TIMESTAMP_FS}.yaml"
    KUBECTX_YAML="${KUBECTX//\\/\\\\}"
    KUBECTX_YAML="${KUBECTX_YAML//\"/\\\"}"

    {
      echo "---"
      echo "kubectx: \"$KUBECTX_YAML\""
      echo "timestamp: \"$TIMESTAMP\""
      echo "---"
    } > "$SAVE_FILE"

    echo "Fetching ClusterSecretStore for context: $KUBECTX" >&2
    clustersecretstore_yaml="$("$KUBECTL_BIN" get clustersecretstore -o yaml 2>/dev/null || true)"
    if [ -n "$clustersecretstore_yaml" ]; then
      echo "---" >> "$SAVE_FILE"
      echo "# ClusterSecretStore resources (cluster-scoped)" >> "$SAVE_FILE"
      echo "$clustersecretstore_yaml" >> "$SAVE_FILE"
      echo "ClusterSecretStore resources saved to $SAVE_FILE" >&2
    else
      echo "No ClusterSecretStore resources found for '$KUBECTX' (or External Secrets Operator not installed)." >&2
    fi
  done

  # Restore original context if we switched
  if [ -n "$ORIGINAL_CTX" ] && [ "$ORIGINAL_CTX" != "$("$KUBECTL_BIN" config current-context 2>/dev/null || true)" ]; then
    "$KUBECTL_BIN" config use-context "$ORIGINAL_CTX" >/dev/null 2>&1 || true
  fi

  print_timing
  exit 0
fi

# Output according to requested format (namespace list only when not saving)
case "$FORMAT" in
  lines)
    if [ ${#result[@]} -eq 0 ]; then
      exit 0
    fi
    for ns in "${result[@]}"; do
      printf '%s\n' "$ns"
    done
    ;;
  csv)
    if [ ${#result[@]} -eq 0 ]; then
      printf ''
      exit 0
    fi
    first=true
    for ns in "${result[@]}"; do
      if [ "$first" = true ]; then
        printf '%s' "$ns"
        first=false
      else
        printf ',%s' "$ns"
      fi
    done
    printf '\n'
    ;;
  array)
    printf 'declare -a %s=( ' "$ARRAY_NAME"
    for ns in "${result[@]}"; do
      esc="${ns//\\/\\\\}"
      esc="${esc//\"/\\\"}"
      printf '"%s" ' "$esc"
    done
    printf ')\n'
    ;;
esac

print_timing
exit 0
